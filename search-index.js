var searchIndex = JSON.parse('{\
"hpke_rs":{"doc":"HPKE","t":[13,13,13,3,13,6,6,6,3,4,3,3,3,13,13,13,13,13,13,13,13,4,13,13,13,13,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,0,11,11,11,11,11,11,11,11,11,11,11,11,11,0,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,16,8,10,5,5,5,5],"n":["Auth","AuthPsk","Base","Context","CryptoError","HPKEKeyPair","HPKEPrivateKey","HPKEPublicKey","Hpke","HpkeError","HpkeKeyPair","HpkePrivateKey","HpkePublicKey","InconsistentPsk","InsecurePsk","InsufficientRandomness","InvalidConfig","InvalidInput","LockPoisoned","MessageLimitReached","MissingPsk","Mode","OpenError","Psk","UnknownMode","UnnecessaryPsk","as_slice","as_slice","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone","clone","clone","clone_into","clone_into","clone_into","clone_into","clone_into","clone_into","default","default","default","derive_key_pair","deserialize","deserialize","deserialize","deserialize","eq","eq","eq","eq","export","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","from","from","from","from","from","from","from","from","from","from_keys","generate_key_pair","into","into","into","into","into","into","into","into_keys","key_schedule","ne","ne","new","new","new","new","open","open","prelude","private_key","public_key","receiver_export","seal","seal","seed","send_export","serialize","serialize","serialize","serialize","setup_receiver","setup_sender","test_util","tls_deserialize","tls_serialize","tls_serialized_len","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","to_string","to_string","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","type_id","type_id","vzip","vzip","vzip","vzip","vzip","vzip","vzip","0","Error","TryFrom","try_from","bytes_to_hex","hex_to_bytes","hex_to_bytes_option","vec_to_option_slice"],"q":["hpke_rs","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","hpke_rs::HpkeError","hpke_rs::prelude","","","hpke_rs::test_util","","",""],"d":["Authenticated HPKE.","Authenticated HPKE with PSK.","HPKE Base mode.","The HPKE context. Note that the RFC currently doesn’t …","An error in the crypto library occurred.","","","","The HPKE configuration struct. This holds the …","HPKE Error types.","An HPKE key pair has an HPKE private and public key.","An HPKE private key is a byte vector.","An HPKE public key is a byte vector.","Inconsistent PSK input.","PSK input is too short (needs to be at least 32 bytes).","Unable to collect enough randomness.","Invalid configuration or arguments.","Invalid input.","A concurrency issue with an <code>RwLock</code>.","The message limit for this AEAD, key, and nonce.","PSK input is required but missing.","HPKE supports four modes.","Error opening an HPKE ciphertext.","HPKE with PSK.","Unknown HPKE mode.","PSK input is provided but not needed.","Get the raw key as byte slice.","Get the raw key as byte slice.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","7.1.2. DeriveKeyPair Derive a key pair for the used KEM …","","","","","","","","","5.3. Secret Export","","","","","","","","","","","","","","","","","","","","","","","","Build a key pair from two keys","Cryptographic Dependencies Randomized algorithm to …","","","","","","","","Split the key pair into the two keys","Creating the Encryption Context Generate the HPKE context …","","","Create a new HPKE public key. Consumes the public key …","Create a new HPKE private key. Consumes the private key …","Create a new HPKE key pair. Consumes the private and …","Set up the configuration for HPKE.","5.2. Encryption and Decryption","Single-Shot APIs 6.1. Encryption and DecryptionSingle shot …","Prelude for HPKE. Include this to get access to all the …","Get a reference to the HPKE private key of this key pair.","Get a reference to the HPKE public key of this key pair.","Single-Shot APIs 6.2. Secret ExportSingle shot API to …","5.2. Encryption and Decryption","Single-Shot APIs 6.1. Encryption and DecryptionSingle shot …","Set PRNG state for testing.","Single-Shot APIs 6.2. Secret ExportSingle shot API to …","","","","","Set up an HPKE receiver.","Set up an HPKE sender.","Test util module. Should be moved really.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","The type returned in the event of a conversion error.","Simple and safe type conversions that may fail in a …","Performs the conversion.","Convert <code>bytes</code> to a hex string.","Convert a hex string to a byte vector.","Convert a hex string to a byte vector. If the input is <code>None</code>…","Convert a byte slice into byte slice option. Returns <code>Nonce</code> …"],"i":[1,1,1,0,2,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,0,2,1,2,2,3,4,5,2,3,4,6,1,7,5,2,3,4,6,1,7,2,3,4,6,1,7,2,3,4,6,1,7,3,4,6,7,3,4,6,1,2,3,4,1,5,5,2,3,4,6,1,1,7,7,5,2,2,3,3,3,4,4,4,6,6,6,1,7,6,7,5,2,3,4,6,1,7,6,7,2,3,3,4,6,7,5,7,0,6,6,7,5,7,7,7,3,4,6,1,7,7,0,3,3,3,2,3,4,6,1,7,1,7,5,2,3,4,6,1,1,7,5,2,3,4,6,1,7,5,2,3,4,6,1,7,5,2,3,4,6,1,7,8,9,0,9,0,0,0,0],"f":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["hpkeerror",4]],[[],["hpkepublickey",3]],[[],["hpkeprivatekey",3]],[[],["hpkekeypair",3]],[[],["mode",4]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["hpkepublickey",3]],[[],["hpkeprivatekey",3]],[[],["hpkekeypair",3]],[[],[["result",4,["hpkekeypair","hpkeerror"]],["hpkekeypair",3],["hpkeerror",4]]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[["hpkeerror",4]],["bool",15]],[[["hpkepublickey",3]],["bool",15]],[[],["bool",15]],[[["mode",4]],["bool",15]],[[["usize",15]],[["result",4,["vec","hpkeerror"]],["vec",3,["u8"]],["hpkeerror",4]]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],[["result",4,["error"]],["error",3]]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[["error",4]]],[[]],[[["u8",15],["vec",3,["u8"]]]],[[]],[[["u8",15],["vec",3,["u8"]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["hpkeprivatekey",3],["hpkepublickey",3]]],[[],[["result",4,["hpkekeypair","hpkeerror"]],["hpkekeypair",3],["hpkeerror",4]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],[["hpkeerror",4],["result",4,["context","hpkeerror"]],["context",3]]],[[["hpkeerror",4]],["bool",15]],[[["hpkepublickey",3]],["bool",15]],[[["u8",15],["vec",3,["u8"]]]],[[["u8",15],["vec",3,["u8"]]]],[[["u8",15],["vec",3,["u8"]]]],[[["mode",4],["kdfalgorithm",4],["aeadalgorithm",4],["kemalgorithm",4]]],[[],[["result",4,["vec","hpkeerror"]],["vec",3,["u8"]],["hpkeerror",4]]],[[["hpkepublickey",3],["hpkeprivatekey",3],["option",4],["option",4,["hpkepublickey"]]],[["result",4,["vec","hpkeerror"]],["vec",3,["u8"]],["hpkeerror",4]]],null,[[],["hpkeprivatekey",3]],[[],["hpkepublickey",3]],[[["hpkepublickey",3],["usize",15],["hpkeprivatekey",3],["option",4],["option",4,["hpkepublickey"]]],[["result",4,["vec","hpkeerror"]],["vec",3,["u8"]],["hpkeerror",4]]],[[],[["result",4,["vec","hpkeerror"]],["vec",3,["u8"]],["hpkeerror",4]]],[[["option",4,["hpkeprivatekey"]],["hpkeprivatekey",3],["hpkepublickey",3],["option",4]],[["hpkeerror",4],["result",4,["hpkeerror"]]]],[[],[["result",4,["hpkeerror"]],["hpkeerror",4]]],[[["usize",15],["option",4,["hpkeprivatekey"]],["hpkeprivatekey",3],["hpkepublickey",3],["option",4]],[["hpkeerror",4],["result",4,["hpkeerror"]]]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[["hpkepublickey",3],["hpkeprivatekey",3],["option",4],["option",4,["hpkepublickey"]]],[["hpkeerror",4],["result",4,["context","hpkeerror"]],["context",3]]],[[["option",4,["hpkeprivatekey"]],["hpkeprivatekey",3],["hpkepublickey",3],["option",4]],[["hpkeerror",4],["result",4,["hpkeerror"]]]],null,[[],[["result",4,["error"]],["error",4]]],[[],[["usize",15],["result",4,["usize","error"]],["error",4]]],[[],["usize",15]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["string",3]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[["u8",15]],[["mode",4],["hpkeerror",4],["result",4,["mode","hpkeerror"]]]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],null,null,null,[[],["result",4]],[[],["string",3]],[[["str",15]],[["u8",15],["vec",3,["u8"]]]],[[["string",3],["option",4,["string"]]],[["u8",15],["vec",3,["u8"]]]],[[],["option",4]]],"p":[[4,"Mode"],[4,"HpkeError"],[3,"HpkePublicKey"],[3,"HpkePrivateKey"],[3,"Context"],[3,"HpkeKeyPair"],[3,"Hpke"],[13,"CryptoError"],[8,"TryFrom"]]}\
}');
if (window.initSearch) {window.initSearch(searchIndex)};